---
layout: post
title: "Java面试题整理（二）"
description: "Java面试题整理（二）"
categories: [java]
tags: [java, 面试题]
---

## Java面试题整理（二）多线程
#### 1. 进程和线程的区别是什么？
进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。
线程又叫做轻量级进程。

#### 2. 创建线程有几种不同的方式？你喜欢哪一种？为什么？
有三种方式可以用来创建线程：
- 1.继承 Thread 类
- 2.实现 Runnable 接口
- 3.应用程序可以使用 Executor 框架来创建线程池

实现 Runnable 接口这种方式更受欢迎，因为这不需要继承 Thread 类。在应用设计中已经继
承了别的对象的情况下，这需要多继承（而 Java 不支持多继承），只能实现接口。同时，线
程池也是非常高效的，很容易实现和使用.

#### 3. 概括的解释下线程的几种可用状态。
线程在执行过程中，可以处于下面几种状态：
- 就绪(Runnable):线程准备运行，不一定立马就能开始执行。
- 运行中(Running)：进程正在执行线程的代码。
- 等待中(Waiting):线程处于阻塞的状态，等待外部的处理结束。
- 睡眠中(Sleeping)：线程被强制睡眠。
- I/O 阻塞(Blocked on I/O)：等待 I/O 操作完成。
- 同步阻塞(Blocked on Synchronization)：等待获取锁。
- 死亡(Dead)：线程完成了执行。

#### 4. 同步方法和同步代码块的区别是什么？
在 Java 语言中，每一个对象有一把锁。线程可以使用 synchronized关键字来获取对象上的锁。
synchronized 关键字可应用在方法级别(粗粒度锁)或者是代码块级别(细粒度锁)。

#### 5. 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？
监视器和锁在 Java 虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。

#### 6. 什么是死锁(deadlock) ？
两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。

#### 7. 如何确保 N  个线程可以访问 N  个资源同时又不导致死锁？
使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。